// IM ADDING SINGN IN LOGIC HERE CUZ THIS IS CONNECTED TO ALL HTMLS
const token = sessionStorage.getItem("token");
const logOut = document.getElementById("logOut");
logOut.addEventListener("click", function () {
  let mockUserId = sessionStorage.getItem("mockUserId");

  fetch("https://68137244129f6313e2114929.mockapi.io/adminNotifications", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({
      message: `User ID:${mockUserId} just signed Out! `,
      type: "signOut",
      timestamp: new Date().toISOString(),
    }),
  });

  setTimeout(() => {
    sessionStorage.clear();
    window.location.href = "signIn.html";
  }, 1000);
});

if (!token && sessionStorage.getItem("isAdmin") === "false" || !token && !sessionStorage.getItem("isAdmin")) {
  window.location.href = "signIn.html";
} else if (sessionStorage.getItem("isAdmin") === "false") {
  fetch("https://api.everrest.educata.dev/auth", {
    method: "GET",
    headers: {
      Authorization: `Bearer ${token}`,
      Accept: "application/json",
    },
  })
    .then((res) => {
      if (!res.ok) {
        throw new Error("Not authenticated");
      }
      return res.json();
    })
    .then((user) => {
      console.log("Current user:", user);
    })
    .catch((err) => {
      console.error(err);
      sessionStorage.removeItem("token");
      window.location.href = "signIn.html";
    });
}

const userPfpIcon = document.getElementById("userProfileIcon");
if (sessionStorage.getItem("isAdmin") === "true") {
  document.getElementById("userProfileHref").href = "admin.html";
  document.getElementById("userProfileHref").classList.add("admin");
}

if (sessionStorage.getItem("isAdmin") === "false") {

  fetch("https://api.everrest.educata.dev/auth", {
    method: "GET",
    headers: {
      Accept: "application/json",
      Authorization: `Bearer ${sessionStorage.getItem("token")}`,
    },
  })
    .then((res) => res.json())
    .then((user) => {
      userPfpIcon.src = user.avatar;
    });
} else {
  userPfpIcon.src = "Images/admin pfp.jpg";
}

let burgerBtn = document.querySelector('.burger-menu')

burgerBtn.addEventListener('click', function(){
  burgerBtn.classList.add("active")
})

let closeBtn = document.querySelector(".closeBtn")

closeBtn.addEventListener("click", function(){
  burgerBtn.classList.remove('active')
})

const translations = {
  იმეილი: {
    en: "Email",
  },

  "იმეილი:": {
    en: "Email:",
  },

  ნომერი: {
    en: "Number",
  },

  გადახდა: {
    en: "Pay",
  },

  საიდან: {
    en: "From",
  },

  სად: {
    en: "Where",
  },

  მგზავრები: {
    en: "Passengers",
  },

  თბილისი: {
    en: "Tbilisi",
  },

  ბათუმი: {
    en: "Batumi",
  },

  ფოთი: {
    en: "Poti",
  },

  დაჯავშნა: {
    en: "Book",
  },

  გამგზავრება: {
    en: "Departure",
  },

  ჩასვლა: {
    en: "Arrive",
  },

  მგზავრი: {
    en: "Passenger",
  },

  "ადგილი:": {
    en: "Seat:",
  },
  სახელი: {
    en: "Name",
  },

  გვარი: {
    en: "Surname",
  },

  "სახელი:": {
    en: "Name:",
  },

  "გვარი:": {
    en: "Surname:",
  },

  ინვოისი: {
    en: "Invoice",
  },

  ფასი: {
    en: "Price",
  },

  ადგილი: {
    en: "Seat",
  },

  სულ: {
    en: "Sum:",
  },

  ბიზნესი: {
    en: "Bussines",
  },

  გასვლა: {
    en: "Departure",
  },

  "გასვლის თარიღი:": {
    en: "Departure date",
  },

  "სულ გადახდილი:": {
    en: "Total Paid",
  },

  "ინვოისი იქმნება კომპიუტერის მიერ და ვალიდურია ბეჭედის და ხელმოწერის გარეშე":
    {
      en: "Invoice is generated by a computer and is valid without signature or seal",
    },

  "გადმოწერეთ ბილეთი ან შეინახეთ ბილეთის ნომერი ადგილზე წარსადგენად.": {
    en: "Downlaod the ticket or save the number to present at the location.",
  },

  "ბილეთის შემოწმება/დაბრუნება": {
    en: "Check Tickets/Refund",
  },

  "შეიძინეთ მატარებლის ბილეთები ონლაინ": {
    en: "Buy train tickets online",
  },

  "გისურვებთ ბედნიერ მგზავრობას": {
    en: "We wish you a happy journey",
    ru: "",
  },

  "დაჯავშნეთ მატარებლის ბილეთი": {
    en: "Book train ticket",
  },

  "მგზავრების რაოდენობა": {
    en: "Passenger quantity",
  },

  "გამგზავრების თარიღი": {
    en: "Departure date",
  },

  "მატარებლის მოძებნა": {
    en: "Search train",
  },
  "მატარებლის ბილეთები": {
    en: "Train tickets",
  },
  "რკინიგზის ბილეთების შესაძენად თქვენ დაგჭირდებათ თითოეული მგზავრის პირადი ნომერი. გთხოვთ მოამზადოთ ეს ინფორმაცია წინასწარ.":
    {
      en: "To buy railway tickets you will need private numbers of each passenger. Please have this information with you.",
    },
  "შეუზღუდავი შეთავაზებები": {
    en: "Unlimited offers",
  },

  "24X7 მხარდაჭერა": {
    en: "24X7 Support",
  },

  "100% უსაფრთხო": {
    en: "100% safe",
  },

  "100% უსაფრთხო გადახდა": {
    en: "100% safe payment",
  },

  "ყველა უფლება დაცულია.": {
    en: "All rights reserved.",
  },

  "თბილისი-ბათუმი": {
    en: "Tbilisi-Batumi Express",
  },
  "ბათუმი-თბილისი": {
    en: "Batumi-Tbilisi Express",
  },
  "თბილისი-ფოთი": {
    en: "Tbilisi-Poti Express",
  },

  "ფოთი-თბილისი": {
    en: "Poti-Tbilisi Express",
  },

  "აირჩიეთ თვქენთვის სასურველი მატარებელი": {
    en: "Choose the train that suits your needs",
  },
  "მატარებლების ჩამონათვალი": {
    en: "Trains List",
  },
  "მატარებლის სახელი": {
    en: "Train Name",
  },

  "პირადი ნომერი:": {
    en: "Private Number:",
  },

  "პირადი ნომერი": {
    en: "Private Number",
  },

  "ადგილის არჩევა": {
    en: "Choose Seat",
  },

  "*მოხდა შეცდომა. ყველა ველი აუცილებლად უნდა შეივსოს": {
    en: "An error occured. Every input is required",
  },

  "მგზავრების მონაცემები": {
    en: "Passengers data",
  },

  "შეიყვანეთ თქვენი მონაცემები": {
    en: "Provide your data",
  },

  "საკონტაქტო ინფორმაცია": {
    en: "Contact Info",
  },

  "მგზავრების ინფორმაცია": {
    en: "Passengers information",
  },

  "წავიკითხე და ვეთანხმები წესებს": {
    en: "I read and agreed to the rules",
  },

  "ბილეთების რეგისტრაცია": {
    en: "Registrate Tickets",
  },

  "1 კლასი": {
    en: "I Class",
  },

  "2 კლასი": {
    en: "II Class",
  },

  "გთხოვთ აირჩიოთ ვაგონი": {
    en: "Please Select a vagon",
  },

  "ვაგონის ნომერი: 1": {
    en: "Vagon Number 1",
  },

  "ვაგონის ნომერი: 2": {
    en: "Vagon Number 2",
  },

  "ვაგონის ნომერი: 3": {
    en: "Vagon Number 3",
  },
  "ტელეფონის ნომერი": {
    en: "Phone Number",
  },
  "ბარათის მფლობელი*": {
    en: "Card Owner*",
  },
  "მოქმედების ვადა*": {
    en: "Valid Until*",
  },
  "ბარათის ნომერი*": {
    en: "Card Number*",
  },
  "სულ გადასახდელი:": {
    en: "Total Must Pay",
  },
  "გადახდის გვერდი": {
    en: "Payment Page",
  },
  "ბილეთის ნომერი:": {
    en: "Ticket Number:",
  },
  "გაცემის თარიღი:": {
    en: "Date given:",
  },
  "ვაგონის N:": {
    en: "Vagon N:",
  },
  "ბილეთი წარმატებით წაიშალა!": {
    en: "Ticket deleted successfully",
  },
  "ბილეთი ვერ წაიშალა!": {
    en: "Couldn't delete ticket!",
  },

  "ბილეთის გაუქმება": {
    en: "Cancel Ticket",
  },

  "ასეთი ბილეთი არ მოიძებნა, შეამოწმეთ ბილეთის ნომერი": {
    en: "Couldn't find the ticket, check ticket number",
  },

  "ბილეთის საფასური გადახდილია, იხილეთ ბილეთი:": {
    en: "Ticket price is paid, see the ticket:",
  },

  შემოწმება: {
    en: "Check",
  },

  "ბილეთის ნომერი": {
    en: "Ticket Number",
  },

  კვირა: {
    en: "Sunday",
  },
  ორშაბათი: {
    en: "Monday",
  },
  სამშაბათი: {
    en: "Tuesday",
  },
  ოთხშაბათი: {
    en: "Wednesday",
  },
  ხუთშაბათი: {
    en: "Thursday",
  },
  პარასკევი: {
    en: "Friday",
  },
  შაბათი: {
    en: "Saturday",
  },
  იანვარი: {
    en: "January",
  },
  თებერვალი: {
    en: "February",
  },
  მარტი: {
    en: "March",
  },
  აპრილი: {
    en: "April",
  },
  მაისი: {
    en: "May",
  },
  ივნისი: {
    en: "June",
  },
  ივლისი: {
    en: "July",
  },
  აგვისტო: {
    en: "August",
  },
  სექტემბერი: {
    en: "September",
  },
  ოქტომბერი: {
    en: "October",
  },
  ნოემბერი: {
    en: "November",
  },
  დეკემბერი: {
    en: "December",
  },
  "სასურველი მატარებელი ვერ მოიძებნა": {
    en: "Couldn't find wanted train!",
  },
};

function applyTranslations(lang) {
  document.querySelectorAll("[data-translate]").forEach((el) => {
    const key = el.getAttribute("data-translate");
    if (translations[key] && translations[key][lang]) {
      el.textContent = translations[key][lang];
    } else {
      el.textContent = key;
    }
  });
  document.querySelectorAll("[data-translate-name]").forEach((el) => {
    const key = el.getAttribute("data-translate-name");
    if (translations[key] && translations[key][lang]) {
      el.setAttribute("name", translations[key][lang]);
    } else {
      el.setAttribute("name", key);
    }
  });

  document.querySelectorAll("[data-translate-value]").forEach((el) => {
    const key = el.getAttribute("data-translate-value");
    if (translations[key] && translations[key][lang]) {
      el.setAttribute("value", translations[key][lang]);
    } else {
      el.setAttribute("value", key);
    }
  });

  document.querySelectorAll("[data-translate-placeholder]").forEach((el) => {
    const key = el.getAttribute("data-translate-placeholder");
    if (translations[key] && translations[key][lang]) {
      el.setAttribute("placeholder", translations[key][lang]);
    } else {
      el.setAttribute("placeholder", key);
    }
  });
}

document.addEventListener("DOMContentLoaded", () => {
  const selector = document.getElementById("lang");
  if (!selector) return;

  selector.addEventListener("change", (e) => {
    const lang = e.target.value;
    applyTranslations(lang);
  });
});

function debounce(func, wait) {
  let timeout;
  return function () {
    clearTimeout(timeout);
    timeout = setTimeout(func, wait);
  };
}

const debouncedApplyTranslations = debounce(() => {
  const lang = document.getElementById("lang")?.value || "ka";
  applyTranslations(lang);
}, 100);

const observer = new MutationObserver(debouncedApplyTranslations);

observer.observe(document.body, {
  childList: true,
  subtree: true,
  attributes: true,
  attributeFilter: [
    "data-translate",
    "data-translate-value",
    "data-translate-placeholder",
    "value",
    "placeholder",
    "class",
  ],
});
